---
title: "Interactivity"
author: "Jarad Niemi"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
layout: page
---

```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

[R Markdown file](25-interactivity.Rmd)

```{r packages}
library("tidyverse"); theme_set(theme_bw())
library("Sleuth3")

# Tables
library("DT")
library("knitr") # for kable
library("kableExtra")
library("formattable")

# Figures
library("scales")
library("plotly")
library("leaflet")
library("gifski")
```

# Tables

We will take a look at the `diamonds` data set. 

```{r}
dim(diamonds)
```

As we will see later, this data is too large for interactive tables and thus
we will take a random sample of these data.



## kable

The `kable()` function in the `knitr` package provides an easy display of 
tables in an HTML document. 

By default, the kable function will show the entire table. 
So, let's just show the first few lines.

```{r diamonds-head}
d <- diamonds %>%
  group_by(cut) %>% # ensure we have all cuts for grouping
  sample_n(3)
```

Also, by default, the table looks pretty bad, so let's add some styling.


```{r kable-diamonds}
knitr::kable(d) %>% 
  kable_styling()
```

### Formatting

```{r kable-diamonds-formatting}
d %>%
knitr::kable(
  caption = "Diamonds data", 
  align = c("rlllrrrrrr")
) %>% 
  kable_styling(bootstrap_options = c('striped', 'hover', 'condensed')) %>%
  scroll_box(height = "200px")
```

### Grouping

```{r kable-diamonds-grouping}
groups <- table(d$cut)

d %>%
knitr::kable(
  caption = "Diamonds data", 
  align = c("rlllrrrrrr")
) %>% 
  kable_styling(bootstrap_options = c('striped', 'hover', 'condensed')) %>%
  pack_rows(
    index = setNames(groups, names(groups))
  )
```

### Highlighting

```{r kable-diamonds-highlighting}
d %>%
  # Conditional highlighting
  mutate(
    carat = cell_spec(carat, "html", color = ifelse(carat > .7, "red", "black")),
    price = cell_spec(price, "html", color = ifelse(price < 5000, "blue", "black"))
  ) %>%
  
knitr::kable(
  escape = FALSE,
  caption = "Diamonds data", 
  align = c("rlllrrrrrr")
) %>% 
  kable_styling(bootstrap_options = c('striped', 'hover', 'condensed'))
```


## formattable

Another function is `formattable()` in the `formattable` package.
The default table is reasonable. 

```{r formattable-diamonds}
d %>%
  formattable::formattable() 
```


```{r formattable-diamonds-highlighting}
d %>%
  
  # Conditional highlighting
  mutate(
    carat = cell_spec(carat, "html", color = ifelse(carat > .7, "red", "black")),
    price = cell_spec(price, "html", color = ifelse(price < 5000, "blue", "black"))
  ) %>%
  
  formattable::formattable(
    list(
      # Width depends on proportion from 0 to max value
      x = color_bar("#C8102E"),    
      y = color_bar("#C8102E"),    
      z = color_bar("#C8102E"),    
      
      # Color depends on proportion from min to max value
      depth = color_tile("#CAC7A7","#524727")
    )
  ) 
```




## DT

As we will see, with the pagination, `datatable()` provides the capability to
succinctly display much larger tables. 
So we will use more data

```{r diamonds-sample}
set.seed(20230416)
d <- diamonds %>%
  sample_n(1000)
```

A basic interactive table using `DT::datatable()`. 

```{r datatable-diamonds}
DT::datatable(d)
```

Many options can be added

### Filtering

```{r datatable-diamonds-filtering}
DT::datatable(d, rownames = FALSE, filter = "top")
```

### Buttons

```{r datatable-diamonds-buttons}
DT::datatable(d, rownames = FALSE, 
              extensions = "Buttons",
              options = list(
                dom = "Bfrtip",
                buttons = c("copy","csv","excel","pdf","print")
              ))
```

### Editing

```{r datatable-diamonds-editing}
DT::datatable(d, rownames = FALSE, 
              editable = TRUE,
              extensions = "Buttons",
              options = list(
                dom = "Bfrtip",
                buttons = c("copy","csv","excel","pdf","print")
              ))
```












# Figures


## Plots

### ggplotly()

#### Scatterplot

Here is a static plot of the diamonds data set. 

```{r}
d <- diamonds %>% sample_n(1000)

g <- ggplot(d, 
            aes(
              x = carat, 
              y = price,
              shape = cut,
              color = color)) + 
  geom_point() +
  scale_y_log10() + 
  scale_x_log10(breaks = scales::breaks_pretty()) 

g
```

```{r}
ggplotly(g)
```

It seems [plotly.js does not support multiple legends](https://github.com/plotly/plotly.js/issues/1668). 


#### Boxplot

```{r}
g <- ggplot(case0501, aes(x = Diet, y = Lifetime)) + 
  geom_boxplot() +
  coord_flip()

ggplotly(g)
```


#### Histogram

```{r}
g <- ggplot(diamonds, aes(x = price)) + 
  geom_histogram(bins = 100)

ggplotly(g)
```



### dygraphs()

Another package from constructing interactive graphics is 
[dygraphs](https://rstudio.github.io/dygraphs/). 





## Maps

### leaflet()

Example taken from [here](https://bookdown.org/yihui/rmarkdown/interactive-documents.html).

```{r out.width='100%'}
leaflet::leaflet() %>% 
  addTiles() %>%
  setView(-93.65, 42.0285, zoom = 17) %>%
  addPopups(
    -93.65, 42.0285,
    'Here is the <b>Department of Statistics</b>, ISU'
  )
```



## animations

```{r bivariate_normal_mcmc, cache=TRUE}
gibbs_bivariate_normal = function(theta0, n_points, rho) {
  theta = matrix(theta0, nrow=n_points, ncol=2, byrow=TRUE)
  v = sqrt(1-rho^2)
  for (i in 2:n_points) {
    theta[i,1] = rnorm(1, rho*theta[i-1,2], v)
    theta[i,2] = rnorm(1, rho*theta[i  ,1], v)
  }
  return(theta)
}

theta = gibbs_bivariate_normal(c(-3,3), n<-20, rho=rho<-0.9)
```

```{r bivariate_normal, dependson='bivariate_normal_mcmc', cache=TRUE}
bivariate_normal_animation = function(x, rho, ask=interactive()) {
  # Create contour plot
  n.out = 101
  xx <- seq(-3, 3, length=n.out)
  grid <- expand.grid(x=xx, y=xx)
  Sigma = diag(rep(.1,2))+rho
  like <- matrix(apply(grid, 1, function(x) mvtnorm::dmvnorm(x,sigma=Sigma)),n.out,n.out)
  
  for (i in 2:nrow(x)) {
    jj = (2:i)[-(i-1)] # vector from 2:(i-1) and NULL if i=2
    for (j in 1:6) {
      plot.new()
      
      # All previous plotting
      contour(xx, xx, like, drawlabels=F, nlevels=10, xlim=c(-3,3), ylim=c(-3,3), 
              xlab=expression(theta[1]), ylab=expression(theta[2]))  
      segments(x[jj-1,1], x[jj-1,2], x[jj,1], x[jj-1,2], col="gray")
      segments(x[jj  ,1], x[jj-1,2], x[jj,1], x[jj  ,2], col="gray")
      points(x[(1:(i-1)),1], x[(1:(i-1)),2], col="red", pch=19)
      
      # New plotting
      if (j>1 & j<4) abline(h=x[i-1,2], lty=2)
      if (j>2) arrows(x[i-1,1], x[i-1,2], x[i,1], x[i-1,2], length=0.1)
      if (j>3 & j<6) abline(v=x[i,1], lty=2)
      if (j>4) arrows(x[i,1], x[i-1,2], x[i,1], x[i,2], length=0.1)
      if (j>5) points(x[i,1], x[i,2], col="red", pch=19)
      
      if (ask) readline("hit <enter>:")
    }
  }
  
  jj=2:nrow(x)
  contour(xx, xx, like, drawlabels=F, nlevels=10, xlim=c(-3,3), ylim=c(-3,3), 
          xlab=expression(theta[1]), ylab=expression(theta[2]))  
  segments(x[jj-1,1], x[jj-1,2], x[jj,1], x[jj-1,2], col="gray")
  segments(x[jj  ,1], x[jj-1,2], x[jj,1], x[jj  ,2], col="gray")
  points(x[,1], x[,2], col="red", pch=19)
}
```

```{r bivariate_normal_animation, dependson=c('bivariate_normal_mcmc','bivariate_normal'), animation.hook='gifski', cache=TRUE, aniopts="controls,loop"}
bivariate_normal_animation(theta, rho = 0.9)
```



## Additional resources/examples

Official:

- [ggplotly gallery](https://plotly.com/ggplot2/)



Individuals:

- [Alex Kaechele](https://rstudio-pubs-static.s3.amazonaws.com/379188_3a2e3e316c604840a53c73151713d7a7.html)
- [richardlent](https://richardlent.github.io/rnotebooks/maps.nb.html)
- [unknown](https://rstudio-pubs-static.s3.amazonaws.com/307862_b8c8460272dc4a2a9023d033d5f3ec34.html)


